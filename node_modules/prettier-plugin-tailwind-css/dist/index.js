'use strict';

var prettierParserHTML = require('prettier/parser-html');
var prettierParserFlow = require('prettier/parser-flow');
var prettierParserTypescript = require('prettier/parser-typescript');
var prettierParserBabel = require('prettier/parser-babel');
var prettierParserPostCss = require('prettier/parser-postcss');
var fs = require('fs');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var prettierParserHTML__default = /*#__PURE__*/_interopDefaultLegacy(prettierParserHTML);
var prettierParserFlow__default = /*#__PURE__*/_interopDefaultLegacy(prettierParserFlow);
var prettierParserTypescript__default = /*#__PURE__*/_interopDefaultLegacy(prettierParserTypescript);
var prettierParserBabel__default = /*#__PURE__*/_interopDefaultLegacy(prettierParserBabel);
var prettierParserPostCss__default = /*#__PURE__*/_interopDefaultLegacy(prettierParserPostCss);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var sortClassArray = function sortClassArray(classArray, sortOrder) {
  return [].concat(_toConsumableArray(classArray.filter(function (el) {
    return sortOrder.indexOf(el) === -1;
  })), _toConsumableArray(classArray.filter(function (el) {
    return sortOrder.indexOf(el) !== -1;
  }).sort(function (a, b) {
    return sortOrder.indexOf(a) - sortOrder.indexOf(b);
  })));
};

var removeDuplicates = function removeDuplicates(classArray) {
  return _toConsumableArray(new Set(classArray));
};

var sortClassString = function sortClassString(classString, sortOrder) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref$shouldRemoveDupl = _ref.shouldRemoveDuplicates,
      shouldRemoveDuplicates = _ref$shouldRemoveDupl === void 0 ? false : _ref$shouldRemoveDupl;

  var classArray = classString.split(/\s+/g);

  if (shouldRemoveDuplicates) {
    classArray = removeDuplicates(classArray);
  }

  classArray = sortClassArray(classArray, sortOrder);
  return classArray.join(' ');
};
var sortClassInText = function sortClassInText(text, regex, classSorter) {
  var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
      _ref2$removeDuplicate = _ref2.removeDuplicates,
      removeDuplicates = _ref2$removeDuplicate === void 0 ? true : _ref2$removeDuplicate;

  var classWrapper;

  while ((classWrapper = regex.exec(text)) !== null) {
    var wrapperMatch = classWrapper[0];
    var valueMatchIndex = classWrapper.findIndex(function (match, idx) {
      return idx !== 0 && match;
    });
    var valueMatch = classWrapper[valueMatchIndex];
    var startPosition = classWrapper.index + wrapperMatch.lastIndexOf(valueMatch);
    var endPosition = startPosition + valueMatch.length;
    var sortedClasses = sortClassString(text.substring(startPosition, endPosition), classSorter, {
      shouldRemoveDuplicates: removeDuplicates
    });
    var beforeClass = text.substring(0, startPosition);
    var afterClass = text.substring(endPosition);
    text = "".concat(beforeClass).concat(sortedClasses).concat(afterClass);
  }

  return text;
};

function getParse(language, defaultParse) {
  return function (text, parsers, options) {
    var sortedText = text;

    if (fs__default['default'].existsSync(options.classRegex) && fs__default['default'].existsSync(options.classSorter)) {
      var classRegex = JSON.parse(fs__default['default'].readFileSync(options.classRegex, 'utf8'));
      var classSorter = JSON.parse(fs__default['default'].readFileSync(options.classSorter, 'utf8'));

      if (language in classRegex && Array.isArray(classSorter)) {
        var classWrapperRegex = new RegExp(classRegex[language], 'gi');
        sortedText = sortClassInText(text, classWrapperRegex, classSorter, {
          removeDuplicates: options.removeDuplicatesClasses
        });
      }
    }

    var result = defaultParse(sortedText, parsers, options);
    return result;
  };
}

var options = {
  removeDuplicatesClasses: {
    type: 'boolean',
    "default": true,
    description: 'remove duplicates classes'
  },
  classRegex: {
    type: 'path',
    "default": "".concat(__dirname, "/regex.json"),
    description: 'regex expression to find classes'
  },
  classSorter: {
    type: 'path',
    "default": "".concat(__dirname, "/sorter.json"),
    description: 'order of the classes'
  }
};

var languages = [{
  name: 'Tailwind JS/JSX',
  extensions: ['.jsx', '.js'],
  parsers: ['flow']
}, {
  name: 'Tailwind TS/TSX',
  extensions: ['.tsx', '.ts'],
  parsers: ['typescript']
}, {
  name: 'Tailwind HTML',
  extensions: ['.html'],
  parsers: ['html']
}, {
  name: 'Tailwind Vue',
  extensions: ['.vue'],
  parsers: ['vue']
}, {
  name: 'Tailwind CSS',
  extensions: ['.css'],
  parsers: ['css']
}, {
  name: 'Tailwind SCSS',
  extensions: ['.scss'],
  parsers: ['scss']
}, {
  name: 'Tailwind Less',
  extensions: ['.less'],
  parsers: ['less']
}];
var parsers = {
  html: _objectSpread2(_objectSpread2({}, prettierParserHTML__default['default'].parsers.html), {}, {
    parse: getParse('html', prettierParserHTML__default['default'].parsers.html.parse)
  }),
  flow: _objectSpread2(_objectSpread2({}, prettierParserFlow__default['default'].parsers.flow), {}, {
    parse: getParse('javascriptreact', prettierParserFlow__default['default'].parsers.flow.parse)
  }),
  typescript: _objectSpread2(_objectSpread2({}, prettierParserTypescript__default['default'].parsers.typescript), {}, {
    parse: getParse('typescriptreact', prettierParserTypescript__default['default'].parsers.typescript.parse)
  }),
  babel: _objectSpread2(_objectSpread2({}, prettierParserBabel__default['default'].parsers.babel), {}, {
    parse: getParse('javascriptreact', prettierParserBabel__default['default'].parsers.babel.parse)
  }),
  vue: _objectSpread2(_objectSpread2({}, prettierParserHTML__default['default'].parsers.vue), {}, {
    parse: getParse('html', prettierParserHTML__default['default'].parsers.vue.parse)
  }),
  css: _objectSpread2(_objectSpread2({}, prettierParserPostCss__default['default'].parsers.css), {}, {
    parse: getParse('css', prettierParserPostCss__default['default'].parsers.css.parse)
  }),
  scss: _objectSpread2(_objectSpread2({}, prettierParserPostCss__default['default'].parsers.scss), {}, {
    parse: getParse('scss', prettierParserPostCss__default['default'].parsers.scss.parse)
  }),
  less: _objectSpread2(_objectSpread2({}, prettierParserPostCss__default['default'].parsers.less), {}, {
    parse: getParse('less', prettierParserPostCss__default['default'].parsers.less.parse)
  })
};
var plugin = {
  languages: languages,
  parsers: parsers,
  options: options
};

module.exports = plugin;
